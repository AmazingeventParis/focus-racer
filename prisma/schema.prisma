generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  PHOTOGRAPHER
  ORGANIZER
  AGENCY
  CLUB
  FEDERATION
  ADMIN
  RUNNER
}

enum EventStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum SportType {
  RUNNING
  TRAIL
  TRIATHLON
  CYCLING
  SWIMMING
  OBSTACLE
  OTHER
}

enum PackType {
  SINGLE
  PACK_5
  PACK_10
  ALL_INCLUSIVE
}

enum OrderStatus {
  PENDING
  PAID
  DELIVERED
  REFUNDED
  EXPIRED
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  password      String
  name          String
  firstName        String?
  lastName         String?
  role          UserRole  @default(PHOTOGRAPHER)
  phone         String?
  avatar        String?
  company       String?
  isActive         Boolean   @default(true)
  emailVerified    DateTime?
  stripeAccountId  String?
  stripeOnboarded  Boolean   @default(false)
  bio              String?
  portfolio        String?
  location         String?
  postalCode       String?
  city             String?
  referralSource   String?
  acceptedCguAt    DateTime?
  newsletterOptIn  Boolean   @default(false)
  credits          Int       @default(0)
  avgRating        Float     @default(0)
  totalReviews     Int       @default(0)
  sportifId        String?   @unique
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  events           Event[]
  orders           Order[]
  creditTransactions CreditTransaction[]
  createdListings    MarketplaceListing[]  @relation("ListingCreator")
  applicationsAsPh   MarketplaceApplication[] @relation("ApplicationPhotographer")
  reviewsGiven       MarketplaceReview[]  @relation("ReviewAuthor")
  reviewsReceived    MarketplaceReview[]  @relation("ReviewTarget")
  supportMessages    SupportMessage[]
  receivedMessages   SupportMessage[]    @relation("MessageRecipient")
  apiKeys            ApiKey[]
  faceImagePath      String?
  eventFavorites     EventFavorite[]
  notifications      Notification[]
  hordeOwned              Horde?                          @relation("HordeOwner")
  hordeMemberships        HordeMember[]                   @relation("HordeMemberUser")
  conversationsCreated    HordeConversation[]             @relation("ConversationCreator")
  conversationMemberships HordeConversationParticipant[]  @relation("ConversationParticipant")
  hordeMessages           HordeMessage[]                  @relation("HordeMessageSender")

  @@index([role])
  @@index([isActive])
}

model Event {
  id           String      @id @default(cuid())
  name         String
  date         DateTime
  location     String?
  description  String?
  sportType    SportType   @default(RUNNING)
  status       EventStatus @default(DRAFT)
  coverImage   String?
  primaryColor String?
  bannerImage  String?
  logoImage    String?
  userId       String
  user         User        @relation(fields: [userId], references: [id])
  photos       Photo[]
  startListEntries StartListEntry[]
  pricePacks   PricePack[]
  orders       Order[]
  faceClusteredAt DateTime? // When face clustering was last run
  uploadStartedAt DateTime? // When the first batch upload started
  uploadCompletedAt DateTime? // When the last photo was processed
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  favorites    EventFavorite[]
  notifications Notification[]

  @@index([userId])
  @@index([status])
}

model Photo {
  id            String      @id @default(cuid())
  filename      String
  originalName  String
  path          String      // HD original (for purchase/download only)
  webPath       String?     // Optimized version for AI pipeline + web display
  s3Key         String?
  thumbnailPath String?
  bibNumbers    BibNumber[]
  faces         PhotoFace[]
  eventId       String
  event         Event       @relation(fields: [eventId], references: [id], onDelete: Cascade)
  orderItems    OrderItem[]
  qualityScore  Float?
  isBlurry      Boolean     @default(false)
  autoEdited    Boolean     @default(false)
  labels        String?
  faceIndexed   Boolean     @default(false)
  ocrProvider      String?
  processedAt      DateTime?
  creditDeducted   Boolean     @default(false)
  creditRefunded   Boolean     @default(false)
  createdAt        DateTime    @default(now())

  @@index([eventId])
}

model BibNumber {
  id         String @id @default(cuid())
  number     String
  photoId    String
  photo      Photo  @relation(fields: [photoId], references: [id], onDelete: Cascade)
  confidence Float?
  source     String @default("ocr") // ocr_tesseract, ocr_aws, face_cluster, manual

  @@unique([photoId, number])
  @@index([number])
  @@index([photoId])
}

model PhotoFace {
  id          String @id @default(cuid())
  photoId     String
  photo       Photo  @relation(fields: [photoId], references: [id], onDelete: Cascade)
  faceId      String // AWS Rekognition FaceId
  confidence  Float?
  boundingBox String? // JSON: {left, top, width, height}
  cropPath    String? // Smart crop path for this face
  createdAt   DateTime @default(now())

  @@index([photoId])
  @@index([faceId])
}

model StartListEntry {
  id         String    @id @default(cuid())
  bibNumber  String
  firstName  String
  lastName   String
  email      String?
  eventId    String
  event      Event     @relation(fields: [eventId], references: [id], onDelete: Cascade)
  notifiedAt DateTime?

  @@unique([eventId, bibNumber])
  @@index([eventId])
}

model PricePack {
  id       String   @id @default(cuid())
  name     String
  type     PackType
  price    Float
  quantity Int?
  isActive Boolean  @default(true)
  eventId  String
  event    Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  orders   Order[]

  @@index([eventId])
}

model Order {
  id                 String      @id @default(cuid())
  userId             String?
  user               User?       @relation(fields: [userId], references: [id])
  guestEmail         String?
  guestName          String?
  eventId            String
  event              Event       @relation(fields: [eventId], references: [id])
  packId             String?
  pack               PricePack?  @relation(fields: [packId], references: [id])
  items              OrderItem[]
  status             OrderStatus @default(PENDING)
  totalAmount        Float
  platformFee        Float       @default(0)
  serviceFee         Float       @default(0)
  stripeFee          Float       @default(0)
  photographerPayout Float       @default(0)
  stripeTransferId   String?
  stripeSessionId    String?     @unique
  stripePaymentId    String?
  downloadToken      String?     @unique
  downloadExpiresAt  DateTime?
  downloadCount      Int         @default(0)
  lastDownloadAt     DateTime?
  createdAt          DateTime    @default(now())
  updatedAt          DateTime    @updatedAt

  @@index([userId])
  @@index([eventId])
  @@index([status])
  @@index([downloadToken])
}

model OrderItem {
  id        String @id @default(cuid())
  orderId   String
  order     Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)
  photoId   String
  photo     Photo  @relation(fields: [photoId], references: [id])
  unitPrice Float

  @@index([orderId])
  @@index([photoId])
}

enum GdprRequestStatus {
  PENDING
  PROCESSING
  COMPLETED
  REJECTED
}

enum GdprRequestType {
  DELETION
  ACCESS
  RECTIFICATION
}

model GdprRequest {
  id            String            @id @default(cuid())
  type          GdprRequestType   @default(DELETION)
  status        GdprRequestStatus @default(PENDING)
  email         String
  name          String
  bibNumber     String?
  eventId       String?
  reason        String?
  adminNote     String?
  processedBy   String?
  processedAt   DateTime?
  photosDeleted Int               @default(0)
  facesDeleted  Int               @default(0)
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  auditLogs     GdprAuditLog[]

  @@index([email])
  @@index([status])
}

model GdprAuditLog {
  id          String      @id @default(cuid())
  requestId   String
  request     GdprRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)
  action      String
  details     String?
  performedBy String?
  createdAt   DateTime    @default(now())

  @@index([requestId])
}

// =========== CREDITS ===========

enum TransactionType {
  PURCHASE
  DEDUCTION
  REFUND
  ADMIN_GRANT
}

model CreditTransaction {
  id            String          @id @default(cuid())
  userId        String
  user          User            @relation(fields: [userId], references: [id])
  type          TransactionType
  amount        Int
  balanceBefore Int
  balanceAfter  Int
  reason        String?
  photoId       String?
  eventId       String?
  createdAt     DateTime        @default(now())

  @@index([userId])
  @@index([createdAt])
}

// =========== MARKETPLACE ===========

enum ListingStatus {
  OPEN
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum ApplicationStatus {
  PENDING
  ACCEPTED
  REJECTED
  WITHDRAWN
}

model MarketplaceListing {
  id           String         @id @default(cuid())
  title        String
  description  String
  sportType    SportType      @default(RUNNING)
  eventDate    DateTime
  eventLocation String
  budget       Float?
  currency     String         @default("EUR")
  status       ListingStatus  @default(OPEN)
  creatorId    String
  creator      User           @relation("ListingCreator", fields: [creatorId], references: [id])
  applications MarketplaceApplication[]
  requirements String?
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt

  @@index([creatorId])
  @@index([status])
  @@index([sportType])
  @@index([eventDate])
}

model MarketplaceApplication {
  id             String            @id @default(cuid())
  listingId      String
  listing        MarketplaceListing @relation(fields: [listingId], references: [id], onDelete: Cascade)
  photographerId String
  photographer   User              @relation("ApplicationPhotographer", fields: [photographerId], references: [id])
  message        String?
  proposedRate   Float?
  status         ApplicationStatus @default(PENDING)
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  @@unique([listingId, photographerId])
  @@index([listingId])
  @@index([photographerId])
  @@index([status])
}

// =========== SUPPORT MESSAGING ===========

enum MessageCategory {
  BILLING
  SORTING
  GDPR
  ACCOUNT
  TECHNICAL
  EVENT
  OTHER
}

enum MessageStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

model SupportMessage {
  id           String          @id @default(cuid())
  userId       String?
  user         User?           @relation(fields: [userId], references: [id])
  recipientId  String?
  recipient    User?           @relation("MessageRecipient", fields: [recipientId], references: [id])
  guestName    String?
  guestEmail   String?
  subject      String
  message      String
  category     MessageCategory @default(OTHER)
  status       MessageStatus   @default(OPEN)
  eventId      String?
  orderId      String?
  adminReply   String?
  repliedBy    String?
  repliedAt    DateTime?
  readByUser      Boolean         @default(true)
  readByRecipient Boolean         @default(true)
  replies         Json            @default("[]")
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  @@index([userId])
  @@index([recipientId])
  @@index([status])
  @@index([category])
  @@index([createdAt])
}

// =========== API KEYS ===========

model ApiKey {
  id         String    @id @default(cuid())
  userId     String
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  name       String
  keyHash    String    @unique
  keyPrefix  String
  isActive   Boolean   @default(true)
  lastUsedAt DateTime?
  createdAt  DateTime  @default(now())

  @@index([userId])
  @@index([keyHash])
}

// =========== PLATFORM SETTINGS ===========

model PlatformSettings {
  id               String   @id @default("default")
  watermarkPath    String?
  watermarkOpacity Float    @default(0.3)
  updatedAt        DateTime @updatedAt
}

model MarketplaceReview {
  id         String   @id @default(cuid())
  authorId   String
  author     User     @relation("ReviewAuthor", fields: [authorId], references: [id])
  targetId   String
  target     User     @relation("ReviewTarget", fields: [targetId], references: [id])
  listingId  String?
  rating     Int
  comment    String?
  createdAt  DateTime @default(now())

  @@index([authorId])
  @@index([targetId])
}

// =========== EVENT FAVORITES ===========

model EventFavorite {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  eventId   String
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([userId, eventId])
  @@index([userId])
  @@index([eventId])
}

// =========== HORDE (SPORTIF GROUPS) ===========

enum HordeMemberStatus {
  PENDING
  ACCEPTED
  DECLINED
}

enum ConversationType {
  GROUP
  DM
}

model Horde {
  id            String              @id @default(cuid())
  ownerId       String              @unique
  owner         User                @relation("HordeOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  name          String              @default("Ma Horde")
  members       HordeMember[]
  conversations HordeConversation[]
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
}

model HordeMember {
  id        String            @id @default(cuid())
  hordeId   String
  horde     Horde             @relation(fields: [hordeId], references: [id], onDelete: Cascade)
  userId    String
  user      User              @relation("HordeMemberUser", fields: [userId], references: [id], onDelete: Cascade)
  status    HordeMemberStatus @default(PENDING)
  invitedAt DateTime          @default(now())
  joinedAt  DateTime?

  @@unique([hordeId, userId])
  @@index([userId])
}

// =========== HORDE CHAT ===========

model HordeConversation {
  id           String                        @id @default(cuid())
  hordeId      String
  horde        Horde                         @relation(fields: [hordeId], references: [id], onDelete: Cascade)
  type         ConversationType
  name         String?
  createdById  String
  createdBy    User                          @relation("ConversationCreator", fields: [createdById], references: [id])
  participants HordeConversationParticipant[]
  messages     HordeMessage[]
  createdAt    DateTime                      @default(now())
  updatedAt    DateTime                      @updatedAt

  @@index([hordeId])
}

model HordeConversationParticipant {
  id             String            @id @default(cuid())
  conversationId String
  conversation   HordeConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  userId         String
  user           User              @relation("ConversationParticipant", fields: [userId], references: [id], onDelete: Cascade)
  lastReadAt     DateTime          @default(now())

  @@unique([conversationId, userId])
  @@index([userId])
}

model HordeMessage {
  id             String            @id @default(cuid())
  conversationId String
  conversation   HordeConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  userId         String
  user           User              @relation("HordeMessageSender", fields: [userId], references: [id], onDelete: Cascade)
  content        String
  createdAt      DateTime          @default(now())

  @@index([conversationId, createdAt])
}

// =========== NOTIFICATIONS ===========

model Notification {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      String   // PHOTOS_AVAILABLE, EVENT_PUBLISHED, WRONG_MATCH_RESOLVED
  title     String
  message   String
  eventId   String?
  event     Event?   @relation(fields: [eventId], references: [id], onDelete: Cascade)
  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([eventId])
  @@index([read])
}
